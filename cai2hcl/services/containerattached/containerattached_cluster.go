// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package containerattached

import (
	"fmt"
	"reflect"

	"github.com/GoogleCloudPlatform/terraform-google-conversion/v2/cai2hcl/common"
	"github.com/GoogleCloudPlatform/terraform-google-conversion/v2/caiasset"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
)

func suppressAttachedClustersLoggingConfigDiff(_, old, new string, d *schema.ResourceData) bool {
	if old == new {
		return true
	}
	_, n := d.GetChange("logging_config.0.component_config.0.enable_components")
	if tpgresource.IsEmptyValue(reflect.ValueOf(n)) {
		return true
	}
	return false
}

const ContainerAttachedClusterAssetType string = "{{location}}-gkemulticloud.googleapis.com/Cluster"

const ContainerAttachedClusterAssetNameRegex string = "projects/(?P<project>[^/]+)/locations/(?P<location>[^/]+)/attachedClusters"

type ContainerAttachedClusterConverter struct {
	name   string
	schema map[string]*schema.Schema
}

func NewContainerAttachedClusterConverter(name string, schema map[string]*schema.Schema) common.Converter {
	return &ContainerAttachedClusterConverter{
		name:   name,
		schema: schema,
	}
}

func (c *ContainerAttachedClusterConverter) Convert(assets []*caiasset.Asset) ([]*common.HCLResourceBlock, error) {
	var blocks []*common.HCLResourceBlock
	config := common.NewConfig()

	for _, asset := range assets {
		if asset == nil {
			continue
		}
		if asset.Resource != nil && asset.Resource.Data != nil {
			block, err := c.convertResourceData(asset, config)
			if err != nil {
				return nil, err
			}
			blocks = append(blocks, block)
		}
	}
	return blocks, nil
}

func (c *ContainerAttachedClusterConverter) convertResourceData(asset *caiasset.Asset, config *transport_tpg.Config) (*common.HCLResourceBlock, error) {
	if asset == nil || asset.Resource == nil || asset.Resource.Data == nil {
		return nil, fmt.Errorf("asset resource data is nil")
	}

	assetResourceData := asset.Resource.Data

	hcl, _ := resourceContainerAttachedClusterRead(assetResourceData, config)

	ctyVal, err := common.MapToCtyValWithSchema(hcl, c.schema)
	if err != nil {
		return nil, err
	}

	resourceName := assetResourceData["name"].(string)

	return &common.HCLResourceBlock{
		Labels: []string{c.name, resourceName},
		Value:  ctyVal,
	}, nil
}

func resourceContainerAttachedClusterRead(resource map[string]interface{}, config *transport_tpg.Config) (map[string]interface{}, error) {
	result := make(map[string]interface{})
	var resource_data *schema.ResourceData = nil

	result["name"] = flattenContainerAttachedClusterName(resource["name"], resource_data, config)
	result["description"] = flattenContainerAttachedClusterDescription(resource["description"], resource_data, config)
	result["oidc_config"] = flattenContainerAttachedClusterOidcConfig(resource["oidcConfig"], resource_data, config)
	result["platform_version"] = flattenContainerAttachedClusterPlatformVersion(resource["platformVersion"], resource_data, config)
	result["distribution"] = flattenContainerAttachedClusterDistribution(resource["distribution"], resource_data, config)
	result["cluster_region"] = flattenContainerAttachedClusterClusterRegion(resource["clusterRegion"], resource_data, config)
	result["fleet"] = flattenContainerAttachedClusterFleet(resource["fleet"], resource_data, config)
	result["state"] = flattenContainerAttachedClusterState(resource["state"], resource_data, config)
	result["uid"] = flattenContainerAttachedClusterUid(resource["uid"], resource_data, config)
	result["reconciling"] = flattenContainerAttachedClusterReconciling(resource["reconciling"], resource_data, config)
	result["create_time"] = flattenContainerAttachedClusterCreateTime(resource["createTime"], resource_data, config)
	result["update_time"] = flattenContainerAttachedClusterUpdateTime(resource["updateTime"], resource_data, config)
	result["kubernetes_version"] = flattenContainerAttachedClusterKubernetesVersion(resource["kubernetesVersion"], resource_data, config)
	result["annotations"] = flattenContainerAttachedClusterAnnotations(resource["annotations"], resource_data, config)
	result["workload_identity_config"] = flattenContainerAttachedClusterWorkloadIdentityConfig(resource["workloadIdentityConfig"], resource_data, config)
	result["logging_config"] = flattenContainerAttachedClusterLoggingConfig(resource["loggingConfig"], resource_data, config)
	result["errors"] = flattenContainerAttachedClusterErrors(resource["errors"], resource_data, config)
	result["authorization"] = flattenContainerAttachedClusterAuthorization(resource["authorization"], resource_data, config)
	result["monitoring_config"] = flattenContainerAttachedClusterMonitoringConfig(resource["monitoringConfig"], resource_data, config)
	result["binary_authorization"] = flattenContainerAttachedClusterBinaryAuthorization(resource["binaryAuthorization"], resource_data, config)
	result["effective_annotations"] = flattenContainerAttachedClusterEffectiveAnnotations(resource["annotations"], resource_data, config)

	return result, nil
}

func flattenContainerAttachedClusterName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.NameFromSelfLinkStateFunc(v)
}

func flattenContainerAttachedClusterDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterOidcConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["issuer_url"] =
		flattenContainerAttachedClusterOidcConfigIssuerUrl(original["issuerUrl"], d, config)
	transformed["jwks"] =
		flattenContainerAttachedClusterOidcConfigJwks(original["jwks"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAttachedClusterOidcConfigIssuerUrl(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterOidcConfigJwks(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterPlatformVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterDistribution(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterClusterRegion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterFleet(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["membership"] =
		flattenContainerAttachedClusterFleetMembership(original["membership"], d, config)
	transformed["project"] =
		flattenContainerAttachedClusterFleetProject(original["project"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAttachedClusterFleetMembership(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterFleetProject(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterUid(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterReconciling(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterKubernetesVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("annotations"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenContainerAttachedClusterWorkloadIdentityConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["identity_provider"] =
		flattenContainerAttachedClusterWorkloadIdentityConfigIdentityProvider(original["identityProvider"], d, config)
	transformed["issuer_uri"] =
		flattenContainerAttachedClusterWorkloadIdentityConfigIssuerUri(original["issuerUri"], d, config)
	transformed["workload_pool"] =
		flattenContainerAttachedClusterWorkloadIdentityConfigWorkloadPool(original["workloadPool"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAttachedClusterWorkloadIdentityConfigIdentityProvider(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterWorkloadIdentityConfigIssuerUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterWorkloadIdentityConfigWorkloadPool(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterLoggingConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["component_config"] =
		flattenContainerAttachedClusterLoggingConfigComponentConfig(original["componentConfig"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAttachedClusterLoggingConfigComponentConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["enable_components"] =
		flattenContainerAttachedClusterLoggingConfigComponentConfigEnableComponents(original["enableComponents"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAttachedClusterLoggingConfigComponentConfigEnableComponents(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterErrors(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"message": flattenContainerAttachedClusterErrorsMessage(original["message"], d, config),
		})
	}
	return transformed
}
func flattenContainerAttachedClusterErrorsMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

// The custom expander transforms input into something like this:
//
//	authorization {
//	   admin_users [
//	     { username = "user1" },
//	     { username = "user2" }
//	   ]
//	   admin_groups [
//	     { group = "group1" },
//	     { group = "group2" },
//	   ]
//	}
//
// The custom flattener transforms input back into something like this:
//
//	authorization {
//	   admin_users = [
//	     "user1",
//	     "user2"
//	   ]
//	   admin_groups = [
//	     "group1",
//	     "group2"
//	   ],
//	}
func flattenContainerAttachedClusterAuthorization(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}

	orig := v.(map[string]interface{})["adminUsers"].([]interface{})
	transformed := make(map[string][]string)
	transformed["admin_users"] = make([]string, len(orig))
	for i, u := range orig {
		if u != nil {
			transformed["admin_users"][i] = u.(map[string]interface{})["username"].(string)
		}
	}
	orig = v.(map[string]interface{})["adminGroups"].([]interface{})
	transformed["admin_groups"] = make([]string, len(orig))
	for i, u := range orig {
		if u != nil {
			transformed["admin_groups"][i] = u.(map[string]interface{})["group"].(string)
		}
	}

	return []interface{}{transformed}
}

func flattenContainerAttachedClusterMonitoringConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["managed_prometheus_config"] =
		flattenContainerAttachedClusterMonitoringConfigManagedPrometheusConfig(original["managedPrometheusConfig"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAttachedClusterMonitoringConfigManagedPrometheusConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["enabled"] =
		flattenContainerAttachedClusterMonitoringConfigManagedPrometheusConfigEnabled(original["enabled"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAttachedClusterMonitoringConfigManagedPrometheusConfigEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterBinaryAuthorization(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	transformed := make(map[string]interface{})
	transformed["evaluation_mode"] =
		flattenContainerAttachedClusterBinaryAuthorizationEvaluationMode(original["evaluationMode"], d, config)
	return []interface{}{transformed}
}
func flattenContainerAttachedClusterBinaryAuthorizationEvaluationMode(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenContainerAttachedClusterEffectiveAnnotations(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}
