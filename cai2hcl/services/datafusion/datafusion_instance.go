// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package datafusion

import (
	"fmt"
	"strings"

	"github.com/GoogleCloudPlatform/terraform-google-conversion/v2/cai2hcl/common"
	"github.com/GoogleCloudPlatform/terraform-google-conversion/v2/caiasset"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
)

var instanceAcceleratorOptions = []string{
	"delta.default.checkpoint.directory",
	"ui.feature.cdc",
}

func instanceOptionsDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the options generated by adding an accelerator to a data fusion instance
	for _, option := range instanceAcceleratorOptions {
		if strings.Contains(k, option) && new == "" {
			return true
		}
	}

	// Let diff be determined by options (above)
	if strings.Contains(k, "options.%") {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

const DataFusionInstanceAssetType string = "datafusion.googleapis.com/Instance"

const DataFusionInstanceAssetNameRegex string = "projects/(?P<project>[^/]+)/locations/(?P<region>[^/]+)/instances"

type DataFusionInstanceConverter struct {
	name   string
	schema map[string]*schema.Schema
}

func NewDataFusionInstanceConverter(name string, schema map[string]*schema.Schema) common.Converter {
	return &DataFusionInstanceConverter{
		name:   name,
		schema: schema,
	}
}

func (c *DataFusionInstanceConverter) Convert(assets []*caiasset.Asset) ([]*common.HCLResourceBlock, error) {
	var blocks []*common.HCLResourceBlock
	config := common.NewConfig()

	for _, asset := range assets {
		if asset == nil {
			continue
		}
		if asset.Resource != nil && asset.Resource.Data != nil {
			block, err := c.convertResourceData(asset, config)
			if err != nil {
				return nil, err
			}
			blocks = append(blocks, block)
		}
	}
	return blocks, nil
}

func (c *DataFusionInstanceConverter) convertResourceData(asset *caiasset.Asset, config *transport_tpg.Config) (*common.HCLResourceBlock, error) {
	if asset == nil || asset.Resource == nil || asset.Resource.Data == nil {
		return nil, fmt.Errorf("asset resource data is nil")
	}

	assetResourceData := asset.Resource.Data

	hcl, _ := resourceDataFusionInstanceRead(assetResourceData, config)

	ctyVal, err := common.MapToCtyValWithSchema(hcl, c.schema)
	if err != nil {
		return nil, err
	}

	resourceName := assetResourceData["name"].(string)

	return &common.HCLResourceBlock{
		Labels: []string{c.name, resourceName},
		Value:  ctyVal,
	}, nil
}

func resourceDataFusionInstanceRead(resource map[string]interface{}, config *transport_tpg.Config) (map[string]interface{}, error) {
	result := make(map[string]interface{})
	var resource_data *schema.ResourceData = nil

	result["name"] = flattenDataFusionInstanceName(resource["name"], resource_data, config)
	result["description"] = flattenDataFusionInstanceDescription(resource["description"], resource_data, config)
	result["type"] = flattenDataFusionInstanceType(resource["type"], resource_data, config)
	result["enable_stackdriver_logging"] = flattenDataFusionInstanceEnableStackdriverLogging(resource["enableStackdriverLogging"], resource_data, config)
	result["enable_stackdriver_monitoring"] = flattenDataFusionInstanceEnableStackdriverMonitoring(resource["enableStackdriverMonitoring"], resource_data, config)
	result["enable_rbac"] = flattenDataFusionInstanceEnableRbac(resource["enableRbac"], resource_data, config)
	result["labels"] = flattenDataFusionInstanceLabels(resource["labels"], resource_data, config)
	result["options"] = flattenDataFusionInstanceOptions(resource["options"], resource_data, config)
	result["create_time"] = flattenDataFusionInstanceCreateTime(resource["createTime"], resource_data, config)
	result["update_time"] = flattenDataFusionInstanceUpdateTime(resource["updateTime"], resource_data, config)
	result["state"] = flattenDataFusionInstanceState(resource["state"], resource_data, config)
	result["state_message"] = flattenDataFusionInstanceStateMessage(resource["stateMessage"], resource_data, config)
	result["service_endpoint"] = flattenDataFusionInstanceServiceEndpoint(resource["serviceEndpoint"], resource_data, config)
	result["version"] = flattenDataFusionInstanceVersion(resource["version"], resource_data, config)
	result["service_account"] = flattenDataFusionInstanceServiceAccount(resource["serviceAccount"], resource_data, config)
	result["private_instance"] = flattenDataFusionInstancePrivateInstance(resource["privateInstance"], resource_data, config)
	result["dataproc_service_account"] = flattenDataFusionInstanceDataprocServiceAccount(resource["dataprocServiceAccount"], resource_data, config)
	result["tenant_project_id"] = flattenDataFusionInstanceTenantProjectId(resource["tenantProjectId"], resource_data, config)
	result["gcs_bucket"] = flattenDataFusionInstanceGcsBucket(resource["gcsBucket"], resource_data, config)
	result["network_config"] = flattenDataFusionInstanceNetworkConfig(resource["networkConfig"], resource_data, config)
	result["zone"] = flattenDataFusionInstanceZone(resource["zone"], resource_data, config)
	result["display_name"] = flattenDataFusionInstanceDisplayName(resource["displayName"], resource_data, config)
	result["api_endpoint"] = flattenDataFusionInstanceApiEndpoint(resource["apiEndpoint"], resource_data, config)
	result["p4_service_account"] = flattenDataFusionInstanceP4ServiceAccount(resource["p4ServiceAccount"], resource_data, config)
	result["crypto_key_config"] = flattenDataFusionInstanceCryptoKeyConfig(resource["cryptoKeyConfig"], resource_data, config)
	result["event_publish_config"] = flattenDataFusionInstanceEventPublishConfig(resource["eventPublishConfig"], resource_data, config)
	result["accelerators"] = flattenDataFusionInstanceAccelerators(resource["accelerators"], resource_data, config)
	result["terraform_labels"] = flattenDataFusionInstanceTerraformLabels(resource["labels"], resource_data, config)
	result["effective_labels"] = flattenDataFusionInstanceEffectiveLabels(resource["labels"], resource_data, config)

	return result, nil
}

func flattenDataFusionInstanceName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.NameFromSelfLinkStateFunc(v)
}

func flattenDataFusionInstanceDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceEnableStackdriverLogging(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceEnableStackdriverMonitoring(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceEnableRbac(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenDataFusionInstanceOptions(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceCreateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceUpdateTime(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceStateMessage(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceServiceEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceVersion(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstancePrivateInstance(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceDataprocServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceTenantProjectId(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceGcsBucket(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceNetworkConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["ip_allocation"] =
		flattenDataFusionInstanceNetworkConfigIpAllocation(original["ipAllocation"], d, config)
	transformed["network"] =
		flattenDataFusionInstanceNetworkConfigNetwork(original["network"], d, config)
	return []interface{}{transformed}
}
func flattenDataFusionInstanceNetworkConfigIpAllocation(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceNetworkConfigNetwork(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceDisplayName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceApiEndpoint(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceP4ServiceAccount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceCryptoKeyConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["key_reference"] =
		flattenDataFusionInstanceCryptoKeyConfigKeyReference(original["keyReference"], d, config)
	return []interface{}{transformed}
}
func flattenDataFusionInstanceCryptoKeyConfigKeyReference(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceEventPublishConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["enabled"] =
		flattenDataFusionInstanceEventPublishConfigEnabled(original["enabled"], d, config)
	transformed["topic"] =
		flattenDataFusionInstanceEventPublishConfigTopic(original["topic"], d, config)
	return []interface{}{transformed}
}
func flattenDataFusionInstanceEventPublishConfigEnabled(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceEventPublishConfigTopic(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceAccelerators(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"accelerator_type": flattenDataFusionInstanceAcceleratorsAcceleratorType(original["acceleratorType"], d, config),
			"state":            flattenDataFusionInstanceAcceleratorsState(original["state"], d, config),
		})
	}
	return transformed
}
func flattenDataFusionInstanceAcceleratorsAcceleratorType(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceAcceleratorsState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenDataFusionInstanceTerraformLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}

	transformed := make(map[string]interface{})
	if l, ok := d.GetOkExists("terraform_labels"); ok {
		for k := range l.(map[string]interface{}) {
			transformed[k] = v.(map[string]interface{})[k]
		}
	}

	return transformed
}

func flattenDataFusionInstanceEffectiveLabels(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}
