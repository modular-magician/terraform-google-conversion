// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package cloudscheduler

import (
	"context"
	"fmt"
	"regexp"
	"strings"

	"github.com/GoogleCloudPlatform/terraform-google-conversion/v2/cai2hcl/common"
	"github.com/GoogleCloudPlatform/terraform-google-conversion/v2/caiasset"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
)

// Both oidc and oauth headers cannot be set
func validateAuthHeaders(_ context.Context, diff *schema.ResourceDiff, v interface{}) error {
	httpBlock := diff.Get("http_target.0").(map[string]interface{})

	if httpBlock != nil {
		oauth := httpBlock["oauth_token"]
		oidc := httpBlock["oidc_token"]

		if oauth != nil && oidc != nil {
			if len(oidc.([]interface{})) > 0 && len(oauth.([]interface{})) > 0 {
				return fmt.Errorf("Error in http_target: only one of oauth_token or oidc_token can be specified, but not both.")
			}
		}
	}

	return nil
}

func authHeaderDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// If generating an `oauth_token` and `scope` is not provided in the configuration,
	// the default "https://www.googleapis.com/auth/cloud-platform" scope will be used.
	// Similarly, if generating an `oidc_token` and `audience` is not provided in the
	// configuration, the URI specified in target will be used. Although not in the
	// configuration, in both cases the default is returned in the object, but is not in.
	// state. We suppress the diff if the values are these defaults but are not stored in state.

	b := strings.Split(k, ".")
	if b[0] == "http_target" && len(b) > 4 {
		block := b[2]
		attr := b[4]

		if block == "oauth_token" && attr == "scope" {
			if old == tpgresource.CanonicalizeServiceScope("cloud-platform") && new == "" {
				return true
			}
		}

		if block == "oidc_token" && attr == "audience" {
			uri := d.Get(strings.Join(b[0:2], ".") + ".uri")
			if old == uri && new == "" {
				return true
			}
		}

	}

	return false
}

func validateHttpHeaders() schema.SchemaValidateFunc {
	return func(i interface{}, k string) (s []string, es []error) {
		headers := i.(map[string]interface{})
		if _, ok := headers["Content-Length"]; ok {
			es = append(es, fmt.Errorf("Cannot set the Content-Length header on %s", k))
			return
		}
		r := regexp.MustCompile(`(X-Google-|X-AppEngine-).*`)
		for key := range headers {
			if r.MatchString(key) {
				es = append(es, fmt.Errorf("Cannot set the %s header on %s", key, k))
				return
			}
		}

		return
	}
}

const CloudSchedulerJobAssetType string = "cloudscheduler.googleapis.com/Job"

const CloudSchedulerJobAssetNameRegex string = "projects/(?P<project>[^/]+)/locations/(?P<region>[^/]+)/jobs"

type CloudSchedulerJobConverter struct {
	name   string
	schema map[string]*schema.Schema
}

func NewCloudSchedulerJobConverter(name string, schema map[string]*schema.Schema) common.Converter {
	return &CloudSchedulerJobConverter{
		name:   name,
		schema: schema,
	}
}

func (c *CloudSchedulerJobConverter) Convert(assets []*caiasset.Asset) ([]*common.HCLResourceBlock, error) {
	var blocks []*common.HCLResourceBlock
	config := common.NewConfig()

	for _, asset := range assets {
		if asset == nil {
			continue
		}
		if asset.Resource != nil && asset.Resource.Data != nil {
			block, err := c.convertResourceData(asset, config)
			if err != nil {
				return nil, err
			}
			blocks = append(blocks, block)
		}
	}
	return blocks, nil
}

func (c *CloudSchedulerJobConverter) convertResourceData(asset *caiasset.Asset, config *transport_tpg.Config) (*common.HCLResourceBlock, error) {
	if asset == nil || asset.Resource == nil || asset.Resource.Data == nil {
		return nil, fmt.Errorf("asset resource data is nil")
	}

	assetResourceData := asset.Resource.Data

	hcl, _ := resourceCloudSchedulerJobRead(assetResourceData, config)

	ctyVal, err := common.MapToCtyValWithSchema(hcl, c.schema)
	if err != nil {
		return nil, err
	}

	resourceName := assetResourceData["name"].(string)

	return &common.HCLResourceBlock{
		Labels: []string{c.name, resourceName},
		Value:  ctyVal,
	}, nil
}

func resourceCloudSchedulerJobRead(resource map[string]interface{}, config *transport_tpg.Config) (map[string]interface{}, error) {
	result := make(map[string]interface{})
	var resource_data *schema.ResourceData = nil

	result["name"] = flattenCloudSchedulerJobName(resource["name"], resource_data, config)
	result["description"] = flattenCloudSchedulerJobDescription(resource["description"], resource_data, config)
	result["schedule"] = flattenCloudSchedulerJobSchedule(resource["schedule"], resource_data, config)
	result["time_zone"] = flattenCloudSchedulerJobTimeZone(resource["timeZone"], resource_data, config)
	result["state"] = flattenCloudSchedulerJobState(resource["state"], resource_data, config)
	result["paused"] = flattenCloudSchedulerJobPaused(resource["paused"], resource_data, config)
	result["attempt_deadline"] = flattenCloudSchedulerJobAttemptDeadline(resource["attemptDeadline"], resource_data, config)
	result["retry_config"] = flattenCloudSchedulerJobRetryConfig(resource["retryConfig"], resource_data, config)
	result["pubsub_target"] = flattenCloudSchedulerJobPubsubTarget(resource["pubsubTarget"], resource_data, config)
	result["app_engine_http_target"] = flattenCloudSchedulerJobAppEngineHttpTarget(resource["appEngineHttpTarget"], resource_data, config)
	result["http_target"] = flattenCloudSchedulerJobHttpTarget(resource["httpTarget"], resource_data, config)

	return result, nil
}

func flattenCloudSchedulerJobName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return v
	}
	return tpgresource.NameFromSelfLinkStateFunc(v)
}

func flattenCloudSchedulerJobDescription(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobSchedule(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobTimeZone(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobState(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobPaused(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	state := d.Get("state")
	if state == "PAUSED" {
		return true
	}
	if state == "ENABLED" {
		return false
	}
	return false // Job has an error state that's not paused or enabled
}

func flattenCloudSchedulerJobAttemptDeadline(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobRetryConfig(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["retry_count"] =
		flattenCloudSchedulerJobRetryConfigRetryCount(original["retryCount"], d, config)
	transformed["max_retry_duration"] =
		flattenCloudSchedulerJobRetryConfigMaxRetryDuration(original["maxRetryDuration"], d, config)
	transformed["min_backoff_duration"] =
		flattenCloudSchedulerJobRetryConfigMinBackoffDuration(original["minBackoffDuration"], d, config)
	transformed["max_backoff_duration"] =
		flattenCloudSchedulerJobRetryConfigMaxBackoffDuration(original["maxBackoffDuration"], d, config)
	transformed["max_doublings"] =
		flattenCloudSchedulerJobRetryConfigMaxDoublings(original["maxDoublings"], d, config)
	return []interface{}{transformed}
}
func flattenCloudSchedulerJobRetryConfigRetryCount(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudSchedulerJobRetryConfigMaxRetryDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobRetryConfigMinBackoffDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobRetryConfigMaxBackoffDuration(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobRetryConfigMaxDoublings(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := tpgresource.StringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudSchedulerJobPubsubTarget(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["topic_name"] =
		flattenCloudSchedulerJobPubsubTargetTopicName(original["topicName"], d, config)
	transformed["data"] =
		flattenCloudSchedulerJobPubsubTargetData(original["data"], d, config)
	transformed["attributes"] =
		flattenCloudSchedulerJobPubsubTargetAttributes(original["attributes"], d, config)
	return []interface{}{transformed}
}
func flattenCloudSchedulerJobPubsubTargetTopicName(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobPubsubTargetData(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobPubsubTargetAttributes(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobAppEngineHttpTarget(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["http_method"] =
		flattenCloudSchedulerJobAppEngineHttpTargetHttpMethod(original["httpMethod"], d, config)
	transformed["app_engine_routing"] =
		flattenCloudSchedulerJobAppEngineHttpTargetAppEngineRouting(original["appEngineRouting"], d, config)
	transformed["relative_uri"] =
		flattenCloudSchedulerJobAppEngineHttpTargetRelativeUri(original["relativeUri"], d, config)
	transformed["body"] =
		flattenCloudSchedulerJobAppEngineHttpTargetBody(original["body"], d, config)
	transformed["headers"] =
		flattenCloudSchedulerJobAppEngineHttpTargetHeaders(original["headers"], d, config)
	return []interface{}{transformed}
}
func flattenCloudSchedulerJobAppEngineHttpTargetHttpMethod(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

// An `appEngineRouting` in API response is useless, so we set config values rather than api response to state.
func flattenCloudSchedulerJobAppEngineHttpTargetAppEngineRouting(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	if stateV, ok := d.GetOk("app_engine_http_target"); ok && len(stateV.([]interface{})) > 0 {
		return d.Get("app_engine_http_target.0.app_engine_routing")
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service"] = original["service"]
	transformed["version"] = original["version"]
	transformed["instance"] = original["instance"]
	return []interface{}{transformed}
}

func flattenCloudSchedulerJobAppEngineHttpTargetRelativeUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobAppEngineHttpTargetBody(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobAppEngineHttpTargetHeaders(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	var headers = v.(map[string]interface{})
	if v, ok := headers["User-Agent"]; ok {
		if v.(string) == "AppEngine-Google; (+http://code.google.com/appengine)" {
			delete(headers, "User-Agent")
		} else if v.(string) == "Google-Cloud-Scheduler" {
			delete(headers, "User-Agent")
		} else {
			headers["User-Agent"] = strings.TrimSpace(strings.Replace(v.(string), "AppEngine-Google; (+http://code.google.com/appengine)", "", -1))
		}
	}
	if v, ok := headers["Content-Type"]; ok {
		if v.(string) == "application/octet-stream" {
			delete(headers, "Content-Type")
		}
	}
	r := regexp.MustCompile(`(X-Google-|X-AppEngine-|Content-Length).*`)
	for key := range headers {
		if r.MatchString(key) {
			delete(headers, key)
		}
	}
	return headers
}

func flattenCloudSchedulerJobHttpTarget(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["uri"] =
		flattenCloudSchedulerJobHttpTargetUri(original["uri"], d, config)
	transformed["http_method"] =
		flattenCloudSchedulerJobHttpTargetHttpMethod(original["httpMethod"], d, config)
	transformed["body"] =
		flattenCloudSchedulerJobHttpTargetBody(original["body"], d, config)
	transformed["headers"] =
		flattenCloudSchedulerJobHttpTargetHeaders(original["headers"], d, config)
	transformed["oauth_token"] =
		flattenCloudSchedulerJobHttpTargetOauthToken(original["oauthToken"], d, config)
	transformed["oidc_token"] =
		flattenCloudSchedulerJobHttpTargetOidcToken(original["oidcToken"], d, config)
	return []interface{}{transformed}
}
func flattenCloudSchedulerJobHttpTargetUri(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobHttpTargetHttpMethod(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobHttpTargetBody(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobHttpTargetHeaders(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	var headers = v.(map[string]interface{})
	if v, ok := headers["User-Agent"]; ok {
		if v.(string) == "AppEngine-Google; (+http://code.google.com/appengine)" {
			delete(headers, "User-Agent")
		} else if v.(string) == "Google-Cloud-Scheduler" {
			delete(headers, "User-Agent")
		} else {
			headers["User-Agent"] = strings.TrimSpace(strings.Replace(v.(string), "AppEngine-Google; (+http://code.google.com/appengine)", "", -1))
		}
	}
	if v, ok := headers["Content-Type"]; ok {
		if v.(string) == "application/octet-stream" {
			delete(headers, "Content-Type")
		}
	}
	r := regexp.MustCompile(`(X-Google-|X-AppEngine-|Content-Length).*`)
	for key := range headers {
		if r.MatchString(key) {
			delete(headers, key)
		}
	}
	return headers
}

func flattenCloudSchedulerJobHttpTargetOauthToken(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_account_email"] =
		flattenCloudSchedulerJobHttpTargetOauthTokenServiceAccountEmail(original["serviceAccountEmail"], d, config)
	transformed["scope"] =
		flattenCloudSchedulerJobHttpTargetOauthTokenScope(original["scope"], d, config)
	return []interface{}{transformed}
}
func flattenCloudSchedulerJobHttpTargetOauthTokenServiceAccountEmail(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobHttpTargetOauthTokenScope(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobHttpTargetOidcToken(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["service_account_email"] =
		flattenCloudSchedulerJobHttpTargetOidcTokenServiceAccountEmail(original["serviceAccountEmail"], d, config)
	transformed["audience"] =
		flattenCloudSchedulerJobHttpTargetOidcTokenAudience(original["audience"], d, config)
	return []interface{}{transformed}
}
func flattenCloudSchedulerJobHttpTargetOidcTokenServiceAccountEmail(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}

func flattenCloudSchedulerJobHttpTargetOidcTokenAudience(v interface{}, d *schema.ResourceData, config *transport_tpg.Config) interface{} {
	return v
}
