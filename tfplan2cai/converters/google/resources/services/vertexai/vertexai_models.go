// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package vertexai

import (
	"reflect"

	"github.com/GoogleCloudPlatform/terraform-google-conversion/v5/tfplan2cai/converters/google/resources/cai"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
)

const VertexAIModelsAssetType string = "aiplatform.googleapis.com/Models"

func ResourceConverterVertexAIModels() cai.ResourceConverter {
	return cai.ResourceConverter{
		AssetType: VertexAIModelsAssetType,
		Convert:   GetVertexAIModelsCaiObject,
	}
}

func GetVertexAIModelsCaiObject(d tpgresource.TerraformResourceData, config *transport_tpg.Config) ([]cai.Asset, error) {
	name, err := cai.AssetName(d, config, "//aiplatform.googleapis.com/{{name}}")
	if err != nil {
		return []cai.Asset{}, err
	}
	if obj, err := GetVertexAIModelsApiObject(d, config); err == nil {
		return []cai.Asset{{
			Name: name,
			Type: VertexAIModelsAssetType,
			Resource: &cai.AssetResource{
				Version:              "v1beta1",
				DiscoveryDocumentURI: "https://www.googleapis.com/discovery/v1/apis/aiplatform/v1beta1/rest",
				DiscoveryName:        "Models",
				Data:                 obj,
			},
		}}, nil
	} else {
		return []cai.Asset{}, err
	}
}

func GetVertexAIModelsApiObject(d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	obj := make(map[string]interface{})
	descriptionProp, err := expandVertexAIModelsDescription(d.Get("description"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	metadataSchemaUriProp, err := expandVertexAIModelsMetadataSchemaUri(d.Get("metadata_schema_uri"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("metadata_schema_uri"); !tpgresource.IsEmptyValue(reflect.ValueOf(metadataSchemaUriProp)) && (ok || !reflect.DeepEqual(v, metadataSchemaUriProp)) {
		obj["metadataSchemaUri"] = metadataSchemaUriProp
	}
	predictSchemataProp, err := expandVertexAIModelsPredictSchemata(d.Get("predict_schemata"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("predict_schemata"); !tpgresource.IsEmptyValue(reflect.ValueOf(predictSchemataProp)) && (ok || !reflect.DeepEqual(v, predictSchemataProp)) {
		obj["predictSchemata"] = predictSchemataProp
	}
	pipelineJobProp, err := expandVertexAIModelsPipelineJob(d.Get("pipeline_job"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("pipeline_job"); !tpgresource.IsEmptyValue(reflect.ValueOf(pipelineJobProp)) && (ok || !reflect.DeepEqual(v, pipelineJobProp)) {
		obj["pipelineJob"] = pipelineJobProp
	}
	containerSpecProp, err := expandVertexAIModelsContainerSpec(d.Get("container_spec"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("container_spec"); !tpgresource.IsEmptyValue(reflect.ValueOf(containerSpecProp)) && (ok || !reflect.DeepEqual(v, containerSpecProp)) {
		obj["containerSpec"] = containerSpecProp
	}
	artifactUriProp, err := expandVertexAIModelsArtifactUri(d.Get("artifact_uri"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("artifact_uri"); !tpgresource.IsEmptyValue(reflect.ValueOf(artifactUriProp)) && (ok || !reflect.DeepEqual(v, artifactUriProp)) {
		obj["artifactUri"] = artifactUriProp
	}
	displayNameProp, err := expandVertexAIModelsDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	versionAliasesProp, err := expandVertexAIModelsVersionAliases(d.Get("version_aliases"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("version_aliases"); !tpgresource.IsEmptyValue(reflect.ValueOf(versionAliasesProp)) && (ok || !reflect.DeepEqual(v, versionAliasesProp)) {
		obj["versionAliases"] = versionAliasesProp
	}
	encryptionSpecProp, err := expandVertexAIModelsEncryptionSpec(d.Get("encryption_spec"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("encryption_spec"); !tpgresource.IsEmptyValue(reflect.ValueOf(encryptionSpecProp)) && (ok || !reflect.DeepEqual(v, encryptionSpecProp)) {
		obj["encryptionSpec"] = encryptionSpecProp
	}
	metadataProp, err := expandVertexAIModelsMetadata(d.Get("metadata"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("metadata"); !tpgresource.IsEmptyValue(reflect.ValueOf(metadataProp)) && (ok || !reflect.DeepEqual(v, metadataProp)) {
		obj["metadata"] = metadataProp
	}
	sourceModelProp, err := expandVertexAIModelsSourceModel(d.Get("source_model"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("source_model"); !tpgresource.IsEmptyValue(reflect.ValueOf(sourceModelProp)) && (ok || !reflect.DeepEqual(v, sourceModelProp)) {
		obj["sourceModel"] = sourceModelProp
	}
	modelProp, err := expandVertexAIModelsModel(d.Get("model"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("model"); !tpgresource.IsEmptyValue(reflect.ValueOf(modelProp)) && (ok || !reflect.DeepEqual(v, modelProp)) {
		obj["model"] = modelProp
	}
	modelIdProp, err := expandVertexAIModelsModelId(d.Get("model_id"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("model_id"); !tpgresource.IsEmptyValue(reflect.ValueOf(modelIdProp)) && (ok || !reflect.DeepEqual(v, modelIdProp)) {
		obj["modelId"] = modelIdProp
	}
	labelsProp, err := expandVertexAIModelsEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	return resourceVertexAIModelsEncoder(d, config, obj)
}

func resourceVertexAIModelsEncoder(d tpgresource.TerraformResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	if obj["sourceModel"] != nil {
		delete(obj, "labels")
		delete(obj, "metadata")
	}

	return obj, nil
}

func expandVertexAIModelsDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataSchemaUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsPredictSchemata(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInstanceSchemaUri, err := expandVertexAIModelsPredictSchemataInstanceSchemaUri(original["instance_schema_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstanceSchemaUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instanceSchemaUri"] = transformedInstanceSchemaUri
	}

	transformedParametersSchemaUri, err := expandVertexAIModelsPredictSchemataParametersSchemaUri(original["parameters_schema_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedParametersSchemaUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["parametersSchemaUri"] = transformedParametersSchemaUri
	}

	transformedPredictionSchemaUri, err := expandVertexAIModelsPredictSchemataPredictionSchemaUri(original["prediction_schema_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPredictionSchemaUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["predictionSchemaUri"] = transformedPredictionSchemaUri
	}

	return transformed, nil
}

func expandVertexAIModelsPredictSchemataInstanceSchemaUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsPredictSchemataParametersSchemaUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsPredictSchemataPredictionSchemaUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsPipelineJob(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedImageUri, err := expandVertexAIModelsContainerSpecImageUri(original["image_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedImageUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["imageUri"] = transformedImageUri
	}

	transformedCommand, err := expandVertexAIModelsContainerSpecCommand(original["command"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCommand); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["command"] = transformedCommand
	}

	transformedArgs, err := expandVertexAIModelsContainerSpecArgs(original["args"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedArgs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["args"] = transformedArgs
	}

	transformedEnv, err := expandVertexAIModelsContainerSpecEnv(original["env"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnv); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["env"] = transformedEnv
	}

	transformedPorts, err := expandVertexAIModelsContainerSpecPorts(original["ports"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPorts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ports"] = transformedPorts
	}

	transformedPredictRoute, err := expandVertexAIModelsContainerSpecPredictRoute(original["predict_route"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPredictRoute); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["predictRoute"] = transformedPredictRoute
	}

	transformedHealthRoute, err := expandVertexAIModelsContainerSpecHealthRoute(original["health_route"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHealthRoute); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["healthRoute"] = transformedHealthRoute
	}

	transformedGrpcPorts, err := expandVertexAIModelsContainerSpecGrpcPorts(original["grpc_ports"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGrpcPorts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["grpcPorts"] = transformedGrpcPorts
	}

	transformedDeploymentTimeout, err := expandVertexAIModelsContainerSpecDeploymentTimeout(original["deployment_timeout"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDeploymentTimeout); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["deploymentTimeout"] = transformedDeploymentTimeout
	}

	transformedSharedMemorySizeMb, err := expandVertexAIModelsContainerSpecSharedMemorySizeMb(original["shared_memory_size_mb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSharedMemorySizeMb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sharedMemorySizeMb"] = transformedSharedMemorySizeMb
	}

	transformedStartupProbe, err := expandVertexAIModelsContainerSpecStartupProbe(original["startup_probe"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStartupProbe); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["startupProbe"] = transformedStartupProbe
	}

	transformedHealthProbe, err := expandVertexAIModelsContainerSpecHealthProbe(original["health_probe"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHealthProbe); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["healthProbe"] = transformedHealthProbe
	}

	return transformed, nil
}

func expandVertexAIModelsContainerSpecImageUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecCommand(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecArgs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecEnv(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandVertexAIModelsContainerSpecEnvName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedValue, err := expandVertexAIModelsContainerSpecEnvValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandVertexAIModelsContainerSpecEnvName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecEnvValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecPorts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedContainerPort, err := expandVertexAIModelsContainerSpecPortsContainerPort(original["container_port"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContainerPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["containerPort"] = transformedContainerPort
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandVertexAIModelsContainerSpecPortsContainerPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecPredictRoute(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecHealthRoute(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecGrpcPorts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedContainerPort, err := expandVertexAIModelsContainerSpecGrpcPortsContainerPort(original["container_port"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContainerPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["containerPort"] = transformedContainerPort
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandVertexAIModelsContainerSpecGrpcPortsContainerPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecDeploymentTimeout(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecSharedMemorySizeMb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecStartupProbe(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPeriodSeconds, err := expandVertexAIModelsContainerSpecStartupProbePeriodSeconds(original["period_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeriodSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["periodSeconds"] = transformedPeriodSeconds
	}

	transformedTimeoutSeconds, err := expandVertexAIModelsContainerSpecStartupProbeTimeoutSeconds(original["timeout_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeoutSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["timeoutSeconds"] = transformedTimeoutSeconds
	}

	transformedExec, err := expandVertexAIModelsContainerSpecStartupProbeExec(original["exec"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExec); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["exec"] = transformedExec
	}

	return transformed, nil
}

func expandVertexAIModelsContainerSpecStartupProbePeriodSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecStartupProbeTimeoutSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecStartupProbeExec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCommand, err := expandVertexAIModelsContainerSpecStartupProbeExecCommand(original["command"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCommand); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["command"] = transformedCommand
	}

	return transformed, nil
}

func expandVertexAIModelsContainerSpecStartupProbeExecCommand(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecHealthProbe(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPeriodSeconds, err := expandVertexAIModelsContainerSpecHealthProbePeriodSeconds(original["period_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeriodSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["periodSeconds"] = transformedPeriodSeconds
	}

	transformedTimeoutSeconds, err := expandVertexAIModelsContainerSpecHealthProbeTimeoutSeconds(original["timeout_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeoutSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["timeoutSeconds"] = transformedTimeoutSeconds
	}

	transformedExec, err := expandVertexAIModelsContainerSpecHealthProbeExec(original["exec"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExec); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["exec"] = transformedExec
	}

	return transformed, nil
}

func expandVertexAIModelsContainerSpecHealthProbePeriodSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecHealthProbeTimeoutSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecHealthProbeExec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCommand, err := expandVertexAIModelsContainerSpecHealthProbeExecCommand(original["command"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCommand); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["command"] = transformedCommand
	}

	return transformed, nil
}

func expandVertexAIModelsContainerSpecHealthProbeExecCommand(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsArtifactUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsVersionAliases(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsEncryptionSpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKmsKeyName, err := expandVertexAIModelsEncryptionSpecKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	return transformed, nil
}

func expandVertexAIModelsEncryptionSpecKmsKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadata(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedConfig, err := expandVertexAIModelsMetadataConfig(original["config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["config"] = transformedConfig
	}

	return transformed, nil
}

func expandVertexAIModelsMetadataConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDimensions, err := expandVertexAIModelsMetadataConfigDimensions(original["dimensions"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDimensions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dimensions"] = transformedDimensions
	}

	transformedApproximateNeighborsCount, err := expandVertexAIModelsMetadataConfigApproximateNeighborsCount(original["approximate_neighbors_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedApproximateNeighborsCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["approximateNeighborsCount"] = transformedApproximateNeighborsCount
	}

	transformedShardSize, err := expandVertexAIModelsMetadataConfigShardSize(original["shard_size"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedShardSize); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["shardSize"] = transformedShardSize
	}

	transformedDistanceMeasureType, err := expandVertexAIModelsMetadataConfigDistanceMeasureType(original["distance_measure_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDistanceMeasureType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["distanceMeasureType"] = transformedDistanceMeasureType
	}

	transformedFeatureNormType, err := expandVertexAIModelsMetadataConfigFeatureNormType(original["feature_norm_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFeatureNormType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["featureNormType"] = transformedFeatureNormType
	}

	transformedAlgorithmConfig, err := expandVertexAIModelsMetadataConfigAlgorithmConfig(original["algorithm_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAlgorithmConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["algorithmConfig"] = transformedAlgorithmConfig
	}

	return transformed, nil
}

func expandVertexAIModelsMetadataConfigDimensions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfigApproximateNeighborsCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfigShardSize(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfigDistanceMeasureType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfigFeatureNormType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfigAlgorithmConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTreeAhConfig, err := expandVertexAIModelsMetadataConfigAlgorithmConfigTreeAhConfig(original["tree_ah_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTreeAhConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["treeAhConfig"] = transformedTreeAhConfig
	}

	transformedBruteForceConfig, err := expandVertexAIModelsMetadataConfigAlgorithmConfigBruteForceConfig(original["brute_force_config"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["bruteForceConfig"] = transformedBruteForceConfig
	}

	return transformed, nil
}

func expandVertexAIModelsMetadataConfigAlgorithmConfigTreeAhConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLeafNodeEmbeddingCount, err := expandVertexAIModelsMetadataConfigAlgorithmConfigTreeAhConfigLeafNodeEmbeddingCount(original["leaf_node_embedding_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLeafNodeEmbeddingCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["leafNodeEmbeddingCount"] = transformedLeafNodeEmbeddingCount
	}

	transformedLeafNodesToSearchPercent, err := expandVertexAIModelsMetadataConfigAlgorithmConfigTreeAhConfigLeafNodesToSearchPercent(original["leaf_nodes_to_search_percent"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLeafNodesToSearchPercent); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["leafNodesToSearchPercent"] = transformedLeafNodesToSearchPercent
	}

	return transformed, nil
}

func expandVertexAIModelsMetadataConfigAlgorithmConfigTreeAhConfigLeafNodeEmbeddingCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfigAlgorithmConfigTreeAhConfigLeafNodesToSearchPercent(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfigAlgorithmConfigBruteForceConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandVertexAIModelsSourceModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsModelId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
