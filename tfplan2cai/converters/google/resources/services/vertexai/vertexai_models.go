// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package vertexai

import (
	"fmt"
	"reflect"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/GoogleCloudPlatform/terraform-google-conversion/v5/tfplan2cai/converters/google/resources/cai"
	"github.com/hashicorp/terraform-provider-google-beta/google-beta/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google-beta/google-beta/transport"
)

const VertexAIModelsAssetType string = "aiplatform.googleapis.com/Models"

func ResourceConverterVertexAIModels() cai.ResourceConverter {
	return cai.ResourceConverter{
		AssetType: VertexAIModelsAssetType,
		Convert:   GetVertexAIModelsCaiObject,
	}
}

func GetVertexAIModelsCaiObject(d tpgresource.TerraformResourceData, config *transport_tpg.Config) ([]cai.Asset, error) {
	name, err := cai.AssetName(d, config, "//aiplatform.googleapis.com/{{name}}")
	if err != nil {
		return []cai.Asset{}, err
	}
	if obj, err := GetVertexAIModelsApiObject(d, config); err == nil {
		return []cai.Asset{{
			Name: name,
			Type: VertexAIModelsAssetType,
			Resource: &cai.AssetResource{
				Version:              "v1beta1",
				DiscoveryDocumentURI: "https://www.googleapis.com/discovery/v1/apis/aiplatform/v1beta1/rest",
				DiscoveryName:        "Models",
				Data:                 obj,
			},
		}}, nil
	} else {
		return []cai.Asset{}, err
	}
}

func GetVertexAIModelsApiObject(d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	obj := make(map[string]interface{})
	artifactUriProp, err := expandVertexAIModelsArtifactUri(d.Get("artifact_uri"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("artifact_uri"); !tpgresource.IsEmptyValue(reflect.ValueOf(artifactUriProp)) && (ok || !reflect.DeepEqual(v, artifactUriProp)) {
		obj["artifactUri"] = artifactUriProp
	}
	displayNameProp, err := expandVertexAIModelsDisplayName(d.Get("display_name"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("display_name"); !tpgresource.IsEmptyValue(reflect.ValueOf(displayNameProp)) && (ok || !reflect.DeepEqual(v, displayNameProp)) {
		obj["displayName"] = displayNameProp
	}
	versionAliasesProp, err := expandVertexAIModelsVersionAliases(d.Get("version_aliases"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("version_aliases"); !tpgresource.IsEmptyValue(reflect.ValueOf(versionAliasesProp)) && (ok || !reflect.DeepEqual(v, versionAliasesProp)) {
		obj["versionAliases"] = versionAliasesProp
	}
	sourceModelProp, err := expandVertexAIModelsSourceModel(d.Get("source_model"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("source_model"); !tpgresource.IsEmptyValue(reflect.ValueOf(sourceModelProp)) && (ok || !reflect.DeepEqual(v, sourceModelProp)) {
		obj["sourceModel"] = sourceModelProp
	}
	modelIdProp, err := expandVertexAIModelsModelId(d.Get("model_id"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("model_id"); !tpgresource.IsEmptyValue(reflect.ValueOf(modelIdProp)) && (ok || !reflect.DeepEqual(v, modelIdProp)) {
		obj["modelId"] = modelIdProp
	}
	parentModelProp, err := expandVertexAIModelsParentModel(d.Get("parent_model"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("parent_model"); !tpgresource.IsEmptyValue(reflect.ValueOf(parentModelProp)) && (ok || !reflect.DeepEqual(v, parentModelProp)) {
		obj["parentModel"] = parentModelProp
	}
	descriptionProp, err := expandVertexAIModelsDescription(d.Get("description"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("description"); !tpgresource.IsEmptyValue(reflect.ValueOf(descriptionProp)) && (ok || !reflect.DeepEqual(v, descriptionProp)) {
		obj["description"] = descriptionProp
	}
	metadataSchemaUriProp, err := expandVertexAIModelsMetadataSchemaUri(d.Get("metadata_schema_uri"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("metadata_schema_uri"); !tpgresource.IsEmptyValue(reflect.ValueOf(metadataSchemaUriProp)) && (ok || !reflect.DeepEqual(v, metadataSchemaUriProp)) {
		obj["metadataSchemaUri"] = metadataSchemaUriProp
	}
	predictSchemataProp, err := expandVertexAIModelsPredictSchemata(d.Get("predict_schemata"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("predict_schemata"); !tpgresource.IsEmptyValue(reflect.ValueOf(predictSchemataProp)) && (ok || !reflect.DeepEqual(v, predictSchemataProp)) {
		obj["predictSchemata"] = predictSchemataProp
	}
	containerSpecProp, err := expandVertexAIModelsContainerSpec(d.Get("container_spec"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("container_spec"); !tpgresource.IsEmptyValue(reflect.ValueOf(containerSpecProp)) && (ok || !reflect.DeepEqual(v, containerSpecProp)) {
		obj["containerSpec"] = containerSpecProp
	}
	encryptionSpecProp, err := expandVertexAIModelsEncryptionSpec(d.Get("encryption_spec"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("encryption_spec"); !tpgresource.IsEmptyValue(reflect.ValueOf(encryptionSpecProp)) && (ok || !reflect.DeepEqual(v, encryptionSpecProp)) {
		obj["encryptionSpec"] = encryptionSpecProp
	}
	metadataProp, err := expandVertexAIModelsMetadata(d.Get("metadata"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("metadata"); !tpgresource.IsEmptyValue(reflect.ValueOf(metadataProp)) && (ok || !reflect.DeepEqual(v, metadataProp)) {
		obj["metadata"] = metadataProp
	}
	modelProp, err := expandVertexAIModelsModel(d.Get("model"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("model"); !tpgresource.IsEmptyValue(reflect.ValueOf(modelProp)) && (ok || !reflect.DeepEqual(v, modelProp)) {
		obj["model"] = modelProp
	}
	explanationSpecProp, err := expandVertexAIModelsExplanationSpec(d.Get("explanation_spec"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("explanation_spec"); !tpgresource.IsEmptyValue(reflect.ValueOf(explanationSpecProp)) && (ok || !reflect.DeepEqual(v, explanationSpecProp)) {
		obj["explanationSpec"] = explanationSpecProp
	}
	labelsProp, err := expandVertexAIModelsEffectiveLabels(d.Get("effective_labels"), d, config)
	if err != nil {
		return nil, err
	} else if v, ok := d.GetOkExists("effective_labels"); !tpgresource.IsEmptyValue(reflect.ValueOf(labelsProp)) && (ok || !reflect.DeepEqual(v, labelsProp)) {
		obj["labels"] = labelsProp
	}

	return resourceVertexAIModelsEncoder(d, config, obj)
}

func resourceVertexAIModelsEncoder(d tpgresource.TerraformResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	newObj := make(map[string]interface{})
	name := ""
	if v, ok := d.GetOk("model_id"); ok {
		name = v.(string)
		delete(obj, "modelId")
	} else {
		name = d.Get("name").(string)
	}
	newObj["modelId"] = name
	if v, ok := d.GetOk("parent_model"); ok {
		newObj["parentModel"] = v
		delete(obj, "parentModel")
	}
	newObj["model"] = obj
	return newObj, nil
}

func expandVertexAIModelsArtifactUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsDisplayName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsVersionAliases(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsSourceModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsModelId(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsParentModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsDescription(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataSchemaUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsPredictSchemata(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInstanceSchemaUri, err := expandVertexAIModelsPredictSchemataInstanceSchemaUri(original["instance_schema_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInstanceSchemaUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["instanceSchemaUri"] = transformedInstanceSchemaUri
	}

	transformedParametersSchemaUri, err := expandVertexAIModelsPredictSchemataParametersSchemaUri(original["parameters_schema_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedParametersSchemaUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["parametersSchemaUri"] = transformedParametersSchemaUri
	}

	transformedPredictionSchemaUri, err := expandVertexAIModelsPredictSchemataPredictionSchemaUri(original["prediction_schema_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPredictionSchemaUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["predictionSchemaUri"] = transformedPredictionSchemaUri
	}

	return transformed, nil
}

func expandVertexAIModelsPredictSchemataInstanceSchemaUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsPredictSchemataParametersSchemaUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsPredictSchemataPredictionSchemaUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedImageUri, err := expandVertexAIModelsContainerSpecImageUri(original["image_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedImageUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["imageUri"] = transformedImageUri
	}

	transformedCommand, err := expandVertexAIModelsContainerSpecCommand(original["command"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCommand); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["command"] = transformedCommand
	}

	transformedArgs, err := expandVertexAIModelsContainerSpecArgs(original["args"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedArgs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["args"] = transformedArgs
	}

	transformedEnv, err := expandVertexAIModelsContainerSpecEnv(original["env"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedEnv); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["env"] = transformedEnv
	}

	transformedPorts, err := expandVertexAIModelsContainerSpecPorts(original["ports"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPorts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["ports"] = transformedPorts
	}

	transformedPredictRoute, err := expandVertexAIModelsContainerSpecPredictRoute(original["predict_route"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPredictRoute); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["predictRoute"] = transformedPredictRoute
	}

	transformedHealthRoute, err := expandVertexAIModelsContainerSpecHealthRoute(original["health_route"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHealthRoute); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["healthRoute"] = transformedHealthRoute
	}

	transformedGrpcPorts, err := expandVertexAIModelsContainerSpecGrpcPorts(original["grpc_ports"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGrpcPorts); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["grpcPorts"] = transformedGrpcPorts
	}

	transformedDeploymentTimeout, err := expandVertexAIModelsContainerSpecDeploymentTimeout(original["deployment_timeout"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDeploymentTimeout); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["deploymentTimeout"] = transformedDeploymentTimeout
	}

	transformedSharedMemorySizeMb, err := expandVertexAIModelsContainerSpecSharedMemorySizeMb(original["shared_memory_size_mb"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSharedMemorySizeMb); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sharedMemorySizeMb"] = transformedSharedMemorySizeMb
	}

	transformedStartupProbe, err := expandVertexAIModelsContainerSpecStartupProbe(original["startup_probe"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStartupProbe); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["startupProbe"] = transformedStartupProbe
	}

	transformedHealthProbe, err := expandVertexAIModelsContainerSpecHealthProbe(original["health_probe"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHealthProbe); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["healthProbe"] = transformedHealthProbe
	}

	return transformed, nil
}

func expandVertexAIModelsContainerSpecImageUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecCommand(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecArgs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecEnv(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandVertexAIModelsContainerSpecEnvName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedValue, err := expandVertexAIModelsContainerSpecEnvValue(original["value"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["value"] = transformedValue
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandVertexAIModelsContainerSpecEnvName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecEnvValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecPorts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedContainerPort, err := expandVertexAIModelsContainerSpecPortsContainerPort(original["container_port"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContainerPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["containerPort"] = transformedContainerPort
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandVertexAIModelsContainerSpecPortsContainerPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecPredictRoute(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecHealthRoute(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecGrpcPorts(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedContainerPort, err := expandVertexAIModelsContainerSpecGrpcPortsContainerPort(original["container_port"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedContainerPort); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["containerPort"] = transformedContainerPort
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandVertexAIModelsContainerSpecGrpcPortsContainerPort(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecDeploymentTimeout(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecSharedMemorySizeMb(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecStartupProbe(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPeriodSeconds, err := expandVertexAIModelsContainerSpecStartupProbePeriodSeconds(original["period_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeriodSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["periodSeconds"] = transformedPeriodSeconds
	}

	transformedTimeoutSeconds, err := expandVertexAIModelsContainerSpecStartupProbeTimeoutSeconds(original["timeout_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeoutSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["timeoutSeconds"] = transformedTimeoutSeconds
	}

	transformedExec, err := expandVertexAIModelsContainerSpecStartupProbeExec(original["exec"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExec); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["exec"] = transformedExec
	}

	return transformed, nil
}

func expandVertexAIModelsContainerSpecStartupProbePeriodSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecStartupProbeTimeoutSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecStartupProbeExec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCommand, err := expandVertexAIModelsContainerSpecStartupProbeExecCommand(original["command"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCommand); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["command"] = transformedCommand
	}

	return transformed, nil
}

func expandVertexAIModelsContainerSpecStartupProbeExecCommand(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecHealthProbe(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPeriodSeconds, err := expandVertexAIModelsContainerSpecHealthProbePeriodSeconds(original["period_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPeriodSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["periodSeconds"] = transformedPeriodSeconds
	}

	transformedTimeoutSeconds, err := expandVertexAIModelsContainerSpecHealthProbeTimeoutSeconds(original["timeout_seconds"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTimeoutSeconds); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["timeoutSeconds"] = transformedTimeoutSeconds
	}

	transformedExec, err := expandVertexAIModelsContainerSpecHealthProbeExec(original["exec"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExec); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["exec"] = transformedExec
	}

	return transformed, nil
}

func expandVertexAIModelsContainerSpecHealthProbePeriodSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecHealthProbeTimeoutSeconds(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsContainerSpecHealthProbeExec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedCommand, err := expandVertexAIModelsContainerSpecHealthProbeExecCommand(original["command"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedCommand); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["command"] = transformedCommand
	}

	return transformed, nil
}

func expandVertexAIModelsContainerSpecHealthProbeExecCommand(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsEncryptionSpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedKmsKeyName, err := expandVertexAIModelsEncryptionSpecKmsKeyName(original["kms_key_name"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedKmsKeyName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["kmsKeyName"] = transformedKmsKeyName
	}

	return transformed, nil
}

func expandVertexAIModelsEncryptionSpecKmsKeyName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadata(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedContentsDeltaUri, err := expandVertexAIModelsMetadataContentsDeltaUri(original["contents_delta_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContentsDeltaUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["contentsDeltaUri"] = transformedContentsDeltaUri
	}

	transformedIsCompleteOverwrite, err := expandVertexAIModelsMetadataIsCompleteOverwrite(original["is_complete_overwrite"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIsCompleteOverwrite); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["isCompleteOverwrite"] = transformedIsCompleteOverwrite
	}

	transformedConfig, err := expandVertexAIModelsMetadataConfig(original["config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["config"] = transformedConfig
	}

	return transformed, nil
}

func expandVertexAIModelsMetadataContentsDeltaUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataIsCompleteOverwrite(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDimensions, err := expandVertexAIModelsMetadataConfigDimensions(original["dimensions"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDimensions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dimensions"] = transformedDimensions
	}

	transformedApproximateNeighborsCount, err := expandVertexAIModelsMetadataConfigApproximateNeighborsCount(original["approximate_neighbors_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedApproximateNeighborsCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["approximateNeighborsCount"] = transformedApproximateNeighborsCount
	}

	transformedShardSize, err := expandVertexAIModelsMetadataConfigShardSize(original["shard_size"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedShardSize); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["shardSize"] = transformedShardSize
	}

	transformedDistanceMeasureType, err := expandVertexAIModelsMetadataConfigDistanceMeasureType(original["distance_measure_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDistanceMeasureType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["distanceMeasureType"] = transformedDistanceMeasureType
	}

	transformedFeatureNormType, err := expandVertexAIModelsMetadataConfigFeatureNormType(original["feature_norm_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFeatureNormType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["featureNormType"] = transformedFeatureNormType
	}

	transformedAlgorithmConfig, err := expandVertexAIModelsMetadataConfigAlgorithmConfig(original["algorithm_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAlgorithmConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["algorithmConfig"] = transformedAlgorithmConfig
	}

	return transformed, nil
}

func expandVertexAIModelsMetadataConfigDimensions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfigApproximateNeighborsCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfigShardSize(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfigDistanceMeasureType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfigFeatureNormType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfigAlgorithmConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTreeAhConfig, err := expandVertexAIModelsMetadataConfigAlgorithmConfigTreeAhConfig(original["tree_ah_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTreeAhConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["treeAhConfig"] = transformedTreeAhConfig
	}

	transformedBruteForceConfig, err := expandVertexAIModelsMetadataConfigAlgorithmConfigBruteForceConfig(original["brute_force_config"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["bruteForceConfig"] = transformedBruteForceConfig
	}

	return transformed, nil
}

func expandVertexAIModelsMetadataConfigAlgorithmConfigTreeAhConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLeafNodeEmbeddingCount, err := expandVertexAIModelsMetadataConfigAlgorithmConfigTreeAhConfigLeafNodeEmbeddingCount(original["leaf_node_embedding_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLeafNodeEmbeddingCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["leafNodeEmbeddingCount"] = transformedLeafNodeEmbeddingCount
	}

	transformedLeafNodesToSearchPercent, err := expandVertexAIModelsMetadataConfigAlgorithmConfigTreeAhConfigLeafNodesToSearchPercent(original["leaf_nodes_to_search_percent"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLeafNodesToSearchPercent); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["leafNodesToSearchPercent"] = transformedLeafNodesToSearchPercent
	}

	return transformed, nil
}

func expandVertexAIModelsMetadataConfigAlgorithmConfigTreeAhConfigLeafNodeEmbeddingCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfigAlgorithmConfigTreeAhConfigLeafNodesToSearchPercent(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsMetadataConfigAlgorithmConfigBruteForceConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandVertexAIModelsModel(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	f, err := tpgresource.ParseRegionalFieldValue("models", v.(string), "project", "region", "zone", d, config, true)
	if err != nil {
		return nil, fmt.Errorf("Invalid value for model: %s", err)
	}
	return f.RelativeLink(), nil
}

func expandVertexAIModelsExplanationSpec(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedParameters, err := expandVertexAIModelsExplanationSpecParameters(original["parameters"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedParameters); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["parameters"] = transformedParameters
	}

	transformedMetadata, err := expandVertexAIModelsExplanationSpecMetadata(original["metadata"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMetadata); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["metadata"] = transformedMetadata
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParameters(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTopK, err := expandVertexAIModelsExplanationSpecParametersTopK(original["top_k"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTopK); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["topK"] = transformedTopK
	}

	transformedOutputIndices, err := expandVertexAIModelsExplanationSpecParametersOutputIndices(original["output_indices"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutputIndices); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["outputIndices"] = transformedOutputIndices
	}

	transformedSampledShapleyAttribution, err := expandVertexAIModelsExplanationSpecParametersSampledShapleyAttribution(original["sampled_shapley_attribution"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSampledShapleyAttribution); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["sampledShapleyAttribution"] = transformedSampledShapleyAttribution
	}

	transformedIntegratedGradientsAttribution, err := expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttribution(original["integrated_gradients_attribution"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIntegratedGradientsAttribution); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["integratedGradientsAttribution"] = transformedIntegratedGradientsAttribution
	}

	transformedXraiAttribution, err := expandVertexAIModelsExplanationSpecParametersXraiAttribution(original["xrai_attribution"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedXraiAttribution); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["xraiAttribution"] = transformedXraiAttribution
	}

	transformedExamples, err := expandVertexAIModelsExplanationSpecParametersExamples(original["examples"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExamples); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["examples"] = transformedExamples
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersTopK(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersOutputIndices(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersSampledShapleyAttribution(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedPathCount, err := expandVertexAIModelsExplanationSpecParametersSampledShapleyAttributionPathCount(original["path_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPathCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["pathCount"] = transformedPathCount
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersSampledShapleyAttributionPathCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttribution(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedStepCount, err := expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionStepCount(original["step_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStepCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["stepCount"] = transformedStepCount
	}

	transformedSmoothGradConfig, err := expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionSmoothGradConfig(original["smooth_grad_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSmoothGradConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["smoothGradConfig"] = transformedSmoothGradConfig
	}

	transformedBlurBaselineConfig, err := expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionBlurBaselineConfig(original["blur_baseline_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBlurBaselineConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["blurBaselineConfig"] = transformedBlurBaselineConfig
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionStepCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionSmoothGradConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNoisySampleCount, err := expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionSmoothGradConfigNoisySampleCount(original["noisy_sample_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNoisySampleCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["noisySampleCount"] = transformedNoisySampleCount
	}

	transformedNoiseSigma, err := expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionSmoothGradConfigNoiseSigma(original["noise_sigma"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNoiseSigma); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["noiseSigma"] = transformedNoiseSigma
	}

	transformedFeatureNoiseSigma, err := expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionSmoothGradConfigFeatureNoiseSigma(original["feature_noise_sigma"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFeatureNoiseSigma); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["featureNoiseSigma"] = transformedFeatureNoiseSigma
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionSmoothGradConfigNoisySampleCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionSmoothGradConfigNoiseSigma(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionSmoothGradConfigFeatureNoiseSigma(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNoiseSigma, err := expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionSmoothGradConfigFeatureNoiseSigmaNoiseSigma(original["noise_sigma"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNoiseSigma); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["noiseSigma"] = transformedNoiseSigma
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionSmoothGradConfigFeatureNoiseSigmaNoiseSigma(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionSmoothGradConfigFeatureNoiseSigmaNoiseSigmaName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedSigma, err := expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionSmoothGradConfigFeatureNoiseSigmaNoiseSigmaSigma(original["sigma"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSigma); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["sigma"] = transformedSigma
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionSmoothGradConfigFeatureNoiseSigmaNoiseSigmaName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionSmoothGradConfigFeatureNoiseSigmaNoiseSigmaSigma(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionBlurBaselineConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMaxBlurSigma, err := expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionBlurBaselineConfigMaxBlurSigma(original["max_blur_sigma"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxBlurSigma); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxBlurSigma"] = transformedMaxBlurSigma
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersIntegratedGradientsAttributionBlurBaselineConfigMaxBlurSigma(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersXraiAttribution(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedStepCount, err := expandVertexAIModelsExplanationSpecParametersXraiAttributionStepCount(original["step_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStepCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["stepCount"] = transformedStepCount
	}

	transformedSmoothGradConfig, err := expandVertexAIModelsExplanationSpecParametersXraiAttributionSmoothGradConfig(original["smooth_grad_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedSmoothGradConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["smoothGradConfig"] = transformedSmoothGradConfig
	}

	transformedBlurBaselineConfig, err := expandVertexAIModelsExplanationSpecParametersXraiAttributionBlurBaselineConfig(original["blur_baseline_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedBlurBaselineConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["blurBaselineConfig"] = transformedBlurBaselineConfig
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersXraiAttributionStepCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersXraiAttributionSmoothGradConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNoisySampleCount, err := expandVertexAIModelsExplanationSpecParametersXraiAttributionSmoothGradConfigNoisySampleCount(original["noisy_sample_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNoisySampleCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["noisySampleCount"] = transformedNoisySampleCount
	}

	transformedNoiseSigma, err := expandVertexAIModelsExplanationSpecParametersXraiAttributionSmoothGradConfigNoiseSigma(original["noise_sigma"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNoiseSigma); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["noiseSigma"] = transformedNoiseSigma
	}

	transformedFeatureNoiseSigma, err := expandVertexAIModelsExplanationSpecParametersXraiAttributionSmoothGradConfigFeatureNoiseSigma(original["feature_noise_sigma"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFeatureNoiseSigma); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["featureNoiseSigma"] = transformedFeatureNoiseSigma
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersXraiAttributionSmoothGradConfigNoisySampleCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersXraiAttributionSmoothGradConfigNoiseSigma(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersXraiAttributionSmoothGradConfigFeatureNoiseSigma(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNoiseSigma, err := expandVertexAIModelsExplanationSpecParametersXraiAttributionSmoothGradConfigFeatureNoiseSigmaNoiseSigma(original["noise_sigma"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNoiseSigma); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["noiseSigma"] = transformedNoiseSigma
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersXraiAttributionSmoothGradConfigFeatureNoiseSigmaNoiseSigma(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	req := make([]interface{}, 0, len(l))
	for _, raw := range l {
		if raw == nil {
			continue
		}
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedName, err := expandVertexAIModelsExplanationSpecParametersXraiAttributionSmoothGradConfigFeatureNoiseSigmaNoiseSigmaName(original["name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["name"] = transformedName
		}

		transformedSigma, err := expandVertexAIModelsExplanationSpecParametersXraiAttributionSmoothGradConfigFeatureNoiseSigmaNoiseSigmaSigma(original["sigma"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedSigma); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["sigma"] = transformedSigma
		}

		req = append(req, transformed)
	}
	return req, nil
}

func expandVertexAIModelsExplanationSpecParametersXraiAttributionSmoothGradConfigFeatureNoiseSigmaNoiseSigmaName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersXraiAttributionSmoothGradConfigFeatureNoiseSigmaNoiseSigmaSigma(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersXraiAttributionBlurBaselineConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMaxBlurSigma, err := expandVertexAIModelsExplanationSpecParametersXraiAttributionBlurBaselineConfigMaxBlurSigma(original["max_blur_sigma"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxBlurSigma); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxBlurSigma"] = transformedMaxBlurSigma
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersXraiAttributionBlurBaselineConfigMaxBlurSigma(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersExamples(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedNeighborCount, err := expandVertexAIModelsExplanationSpecParametersExamplesNeighborCount(original["neighbor_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNeighborCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["neighborCount"] = transformedNeighborCount
	}

	transformedExampleGcsSource, err := expandVertexAIModelsExplanationSpecParametersExamplesExampleGcsSource(original["example_gcs_source"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedExampleGcsSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["exampleGcsSource"] = transformedExampleGcsSource
	}

	transformedNearestNeighborSearchConfig, err := expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfig(original["nearest_neighbor_search_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedNearestNeighborSearchConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["nearestNeighborSearchConfig"] = transformedNearestNeighborSearchConfig
	}

	transformedPresets, err := expandVertexAIModelsExplanationSpecParametersExamplesPresets(original["presets"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPresets); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["presets"] = transformedPresets
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNeighborCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesExampleGcsSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDataFormat, err := expandVertexAIModelsExplanationSpecParametersExamplesExampleGcsSourceDataFormat(original["data_format"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDataFormat); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dataFormat"] = transformedDataFormat
	}

	transformedGcsSource, err := expandVertexAIModelsExplanationSpecParametersExamplesExampleGcsSourceGcsSource(original["gcs_source"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedGcsSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["gcsSource"] = transformedGcsSource
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesExampleGcsSourceDataFormat(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesExampleGcsSourceGcsSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedUris, err := expandVertexAIModelsExplanationSpecParametersExamplesExampleGcsSourceGcsSourceUris(original["uris"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedUris); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["uris"] = transformedUris
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesExampleGcsSourceGcsSourceUris(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedContentsDeltaUri, err := expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigContentsDeltaUri(original["contents_delta_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedContentsDeltaUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["contentsDeltaUri"] = transformedContentsDeltaUri
	}

	transformedIsCompleteOverwrite, err := expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigIsCompleteOverwrite(original["is_complete_overwrite"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedIsCompleteOverwrite); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["isCompleteOverwrite"] = transformedIsCompleteOverwrite
	}

	transformedConfig, err := expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfig(original["config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["config"] = transformedConfig
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigContentsDeltaUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigIsCompleteOverwrite(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedDimensions, err := expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigDimensions(original["dimensions"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDimensions); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["dimensions"] = transformedDimensions
	}

	transformedApproximateNeighborsCount, err := expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigApproximateNeighborsCount(original["approximate_neighbors_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedApproximateNeighborsCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["approximateNeighborsCount"] = transformedApproximateNeighborsCount
	}

	transformedShardSize, err := expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigShardSize(original["shard_size"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedShardSize); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["shardSize"] = transformedShardSize
	}

	transformedDistanceMeasureType, err := expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigDistanceMeasureType(original["distance_measure_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedDistanceMeasureType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["distanceMeasureType"] = transformedDistanceMeasureType
	}

	transformedFeatureNormType, err := expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigFeatureNormType(original["feature_norm_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFeatureNormType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["featureNormType"] = transformedFeatureNormType
	}

	transformedAlgorithmConfig, err := expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigAlgorithmConfig(original["algorithm_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedAlgorithmConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["algorithmConfig"] = transformedAlgorithmConfig
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigDimensions(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigApproximateNeighborsCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigShardSize(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigDistanceMeasureType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigFeatureNormType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigAlgorithmConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedTreeAhConfig, err := expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigAlgorithmConfigTreeAhConfig(original["tree_ah_config"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedTreeAhConfig); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["treeAhConfig"] = transformedTreeAhConfig
	}

	transformedBruteForceConfig, err := expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigAlgorithmConfigBruteForceConfig(original["brute_force_config"], d, config)
	if err != nil {
		return nil, err
	} else {
		transformed["bruteForceConfig"] = transformedBruteForceConfig
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigAlgorithmConfigTreeAhConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedLeafNodeEmbeddingCount, err := expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigAlgorithmConfigTreeAhConfigLeafNodeEmbeddingCount(original["leaf_node_embedding_count"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLeafNodeEmbeddingCount); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["leafNodeEmbeddingCount"] = transformedLeafNodeEmbeddingCount
	}

	transformedLeafNodesToSearchPercent, err := expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigAlgorithmConfigTreeAhConfigLeafNodesToSearchPercent(original["leaf_nodes_to_search_percent"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLeafNodesToSearchPercent); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["leafNodesToSearchPercent"] = transformedLeafNodesToSearchPercent
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigAlgorithmConfigTreeAhConfigLeafNodeEmbeddingCount(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigAlgorithmConfigTreeAhConfigLeafNodesToSearchPercent(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesNearestNeighborSearchConfigConfigAlgorithmConfigBruteForceConfig(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 {
		return nil, nil
	}

	if l[0] == nil {
		transformed := make(map[string]interface{})
		return transformed, nil
	}
	transformed := make(map[string]interface{})

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesPresets(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedModality, err := expandVertexAIModelsExplanationSpecParametersExamplesPresetsModality(original["modality"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedModality); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["modality"] = transformedModality
	}

	transformedQuery, err := expandVertexAIModelsExplanationSpecParametersExamplesPresetsQuery(original["query"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedQuery); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["query"] = transformedQuery
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesPresetsModality(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecParametersExamplesPresetsQuery(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadata(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedInputs, err := expandVertexAIModelsExplanationSpecMetadataInputs(original["inputs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedInputs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["inputs"] = transformedInputs
	}

	transformedOutputs, err := expandVertexAIModelsExplanationSpecMetadataOutputs(original["outputs"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOutputs); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["outputs"] = transformedOutputs
	}

	transformedFeatureAttributionsSchemaUri, err := expandVertexAIModelsExplanationSpecMetadataFeatureAttributionsSchemaUri(original["feature_attributions_schema_uri"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedFeatureAttributionsSchemaUri); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["featureAttributionsSchemaUri"] = transformedFeatureAttributionsSchemaUri
	}

	transformedLatentSpaceSource, err := expandVertexAIModelsExplanationSpecMetadataLatentSpaceSource(original["latent_space_source"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLatentSpaceSource); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["latentSpaceSource"] = transformedLatentSpaceSource
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedInputTensorName, err := expandVertexAIModelsExplanationSpecMetadataInputsInputTensorName(original["input_tensor_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedInputTensorName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["inputTensorName"] = transformedInputTensorName
		}

		transformedEncoding, err := expandVertexAIModelsExplanationSpecMetadataInputsEncoding(original["encoding"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEncoding); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["encoding"] = transformedEncoding
		}

		transformedModality, err := expandVertexAIModelsExplanationSpecMetadataInputsModality(original["modality"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedModality); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["modality"] = transformedModality
		}

		transformedFeatureValueDomain, err := expandVertexAIModelsExplanationSpecMetadataInputsFeatureValueDomain(original["feature_value_domain"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedFeatureValueDomain); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["featureValueDomain"] = transformedFeatureValueDomain
		}

		transformedIndicesTensorName, err := expandVertexAIModelsExplanationSpecMetadataInputsIndicesTensorName(original["indices_tensor_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIndicesTensorName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["indicesTensorName"] = transformedIndicesTensorName
		}

		transformedDenseShapeTensorName, err := expandVertexAIModelsExplanationSpecMetadataInputsDenseShapeTensorName(original["dense_shape_tensor_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDenseShapeTensorName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["denseShapeTensorName"] = transformedDenseShapeTensorName
		}

		transformedIndexFeatureMapping, err := expandVertexAIModelsExplanationSpecMetadataInputsIndexFeatureMapping(original["index_feature_mapping"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIndexFeatureMapping); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["indexFeatureMapping"] = transformedIndexFeatureMapping
		}

		transformedEncodedTensorName, err := expandVertexAIModelsExplanationSpecMetadataInputsEncodedTensorName(original["encoded_tensor_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEncodedTensorName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["encodedTensorName"] = transformedEncodedTensorName
		}

		transformedEncodedBaselines, err := expandVertexAIModelsExplanationSpecMetadataInputsEncodedBaselines(original["encoded_baselines"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedEncodedBaselines); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["encodedBaselines"] = transformedEncodedBaselines
		}

		transformedVisualization, err := expandVertexAIModelsExplanationSpecMetadataInputsVisualization(original["visualization"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedVisualization); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["visualization"] = transformedVisualization
		}

		transformedGroupName, err := expandVertexAIModelsExplanationSpecMetadataInputsGroupName(original["group_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedGroupName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["groupName"] = transformedGroupName
		}

		transformedName, err := tpgresource.ExpandString(original["name"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedName] = transformed
	}
	return m, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsInputTensorName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsEncoding(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsModality(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsFeatureValueDomain(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedMinValue, err := expandVertexAIModelsExplanationSpecMetadataInputsFeatureValueDomainMinValue(original["min_value"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMinValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["minValue"] = transformedMinValue
	}

	transformedMaxValue, err := expandVertexAIModelsExplanationSpecMetadataInputsFeatureValueDomainMaxValue(original["max_value"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedMaxValue); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["maxValue"] = transformedMaxValue
	}

	transformedOriginalMean, err := expandVertexAIModelsExplanationSpecMetadataInputsFeatureValueDomainOriginalMean(original["original_mean"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOriginalMean); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["originalMean"] = transformedOriginalMean
	}

	transformedOriginalStddev, err := expandVertexAIModelsExplanationSpecMetadataInputsFeatureValueDomainOriginalStddev(original["original_stddev"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOriginalStddev); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["originalStddev"] = transformedOriginalStddev
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsFeatureValueDomainMinValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsFeatureValueDomainMaxValue(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsFeatureValueDomainOriginalMean(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsFeatureValueDomainOriginalStddev(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsIndicesTensorName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsDenseShapeTensorName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsIndexFeatureMapping(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsEncodedTensorName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsEncodedBaselines(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsVisualization(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedType, err := expandVertexAIModelsExplanationSpecMetadataInputsVisualizationType(original["type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["type"] = transformedType
	}

	transformedPolarity, err := expandVertexAIModelsExplanationSpecMetadataInputsVisualizationPolarity(original["polarity"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedPolarity); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["polarity"] = transformedPolarity
	}

	transformedColorMap, err := expandVertexAIModelsExplanationSpecMetadataInputsVisualizationColorMap(original["color_map"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedColorMap); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["colorMap"] = transformedColorMap
	}

	transformedClipPercentUpperbound, err := expandVertexAIModelsExplanationSpecMetadataInputsVisualizationClipPercentUpperbound(original["clip_percent_upperbound"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClipPercentUpperbound); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clipPercentUpperbound"] = transformedClipPercentUpperbound
	}

	transformedClipPercentLowerbound, err := expandVertexAIModelsExplanationSpecMetadataInputsVisualizationClipPercentLowerbound(original["clip_percent_lowerbound"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedClipPercentLowerbound); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["clipPercentLowerbound"] = transformedClipPercentLowerbound
	}

	transformedOverlayType, err := expandVertexAIModelsExplanationSpecMetadataInputsVisualizationOverlayType(original["overlay_type"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedOverlayType); val.IsValid() && !tpgresource.IsEmptyValue(val) {
		transformed["overlayType"] = transformedOverlayType
	}

	return transformed, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsVisualizationType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsVisualizationPolarity(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsVisualizationColorMap(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsVisualizationClipPercentUpperbound(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsVisualizationClipPercentLowerbound(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsVisualizationOverlayType(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataInputsGroupName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataOutputs(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]interface{}, error) {
	if v == nil {
		return map[string]interface{}{}, nil
	}
	m := make(map[string]interface{})
	for _, raw := range v.(*schema.Set).List() {
		original := raw.(map[string]interface{})
		transformed := make(map[string]interface{})

		transformedOutputTensorName, err := expandVertexAIModelsExplanationSpecMetadataOutputsOutputTensorName(original["output_tensor_name"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedOutputTensorName); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["outputTensorName"] = transformedOutputTensorName
		}

		transformedIndexDisplayNameMapping, err := expandVertexAIModelsExplanationSpecMetadataOutputsIndexDisplayNameMapping(original["index_display_name_mapping"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedIndexDisplayNameMapping); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["indexDisplayNameMapping"] = transformedIndexDisplayNameMapping
		}

		transformedDisplayNameMappingKey, err := expandVertexAIModelsExplanationSpecMetadataOutputsDisplayNameMappingKey(original["display_name_mapping_key"], d, config)
		if err != nil {
			return nil, err
		} else if val := reflect.ValueOf(transformedDisplayNameMappingKey); val.IsValid() && !tpgresource.IsEmptyValue(val) {
			transformed["displayNameMappingKey"] = transformedDisplayNameMappingKey
		}

		transformedName, err := tpgresource.ExpandString(original["name"], d, config)
		if err != nil {
			return nil, err
		}
		m[transformedName] = transformed
	}
	return m, nil
}

func expandVertexAIModelsExplanationSpecMetadataOutputsOutputTensorName(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataOutputsIndexDisplayNameMapping(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataOutputsDisplayNameMappingKey(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataFeatureAttributionsSchemaUri(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsExplanationSpecMetadataLatentSpaceSource(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (interface{}, error) {
	return v, nil
}

func expandVertexAIModelsEffectiveLabels(v interface{}, d tpgresource.TerraformResourceData, config *transport_tpg.Config) (map[string]string, error) {
	if v == nil {
		return map[string]string{}, nil
	}
	m := make(map[string]string)
	for k, val := range v.(map[string]interface{}) {
		m[k] = val.(string)
	}
	return m, nil
}
